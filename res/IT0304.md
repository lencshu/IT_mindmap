# IT

## 计算机三大件

### 存储

### IO

### CPU

## 计算

### 数据与算法

### 状态与转移函数

### 应用分类

- 计算密集型应用
- 数据密集型应用

### 创造性

- 数据模型
- 数据流设计

### 实际生产

- 数据表就是数据结构
- 索引与查询就是算法
- 应用代码往往扮演的是胶水的角色

	- 处理IO与业务逻辑
	- 其他大部分工作都是在数据系统之间搬运数据

## 抽象

### 操作系统提供了对存储的基本抽象

- 内存寻址空间
- 磁盘逻辑块号

### 文件系统提供了文件名到地址空间的KV存储抽象

### 数据库提供了对应用通用存储需求的高级抽象

## 领域

### 数据库

- 有状态的地方就有数据库

	- 网站的背后
	- 应用的内部
	- 单机软件
	- 区块链
	- Web浏览器中

		- 各类状态管理框架
		- 本地存储

- 分类
关系型数据库只是数据系统的冰山一角（或者说冰山之巅）

	- 数据库：存储数据，以便自己或其他应用程序之后能再次找到（PostgreSQL，MySQL，Oracle）

		- 关系型数据库

	- 缓存：记住开销昂贵操作的结果，加快读取速度（Redis，Memcached）
	- 搜索索引：允许用户按关键字搜索数据，或以各种方式对数据进行过滤（ElasticSearch）
	- 流处理：向其他进程发送消息，进行异步处理（Kafka，Flink，Storm）
	- 批处理：定期处理累积的大批量数据（Hadoop）

- 架构师

	- 职能

		- 了解这些组件的性能特点与应用场景
		- 灵活地权衡取舍
		- 集成拼接这些数据系统

	- 挑战

		- 软硬件故障把数据搞成一团浆糊（可靠性）
		- 状态太多而内存太小放不下（可伸缩性）
		- 并发访问控制导致代码复杂度发生爆炸（可维护性）

	- 分拆:架构演化的重要方法论

		- 状态与计算相分离： 数据库将状态管理的职能从应用程序中分拆出来
		- 问题比方法更重要: 每个系统都服务于一个目的，解决一类问题

	- 理解原理

		- 设计系统时以最少的复杂度代价写出更可靠高效的代码
		- 排查疑难杂症时带来精准的直觉与深刻的洞察

- 原理

	- 存储引擎原理（基础）
	- 数据模型设计原理（应用）
就是生产中的数据结构设计
为了把事情做漂亮（可维护）

		- 范式理论: 为了解决数据冗余

			- 冗余度

				- 冗余少则复杂度小/可维护性强
				- 冗余高则性能好

			- 冗余字段能加快特定类型的读取（通过消除连接），但在写入时就需要做更多的工作：维护多对象副本间的一致性，避免多对象事务并发执行时发生踩踏

	- 索引与查询优化器的原理（性能）
关系代数
为了把事情做得快（性能，可扩展）

		- R树索引 GIST索引

	- 事务与并发控制的原理（正确性）
为了把事情做正确

		- 事务是数据处理领域最伟大的抽象之一
提供了很多有用的保证（ACID）
		- 原子性: 提交前能随时中止事务并丢弃所有写入
		- 持久性: 承诺一旦事务成功提交，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失
		- 隔离性:保证同时执行的事务无法相互影响（在可序列化隔离等级下）

	- 故障恢复与复制系统的原理（可靠性）

		- 高可用
		- 核心技术其实就是复制（Replication）（或再加上自动故障切换（Failover））

### 操作系统

### 计算机网络

### 离散数学

### 数字电路

### 体系结构

### 数据结构/算法(基础)

### 编译原理

### 编程思想

- 面向过程
- 面向对象

	- 现实时间的各种关系映射到计算机里
	- 代码组织的方式

## 语言

### python

- Python 之禅
- 特点

	- 易于上手 难于精通
	- 既有动态脚本的特性，又有面向对象的特点
	- 相对于C C++ java慢

		- 编译型

			- C
			- C++

		- 解释型

			- JS
			- python

		- 中间代码

			- Java
			-  C#

	- 开发效率和运行效率

- 用途

	- 爬虫
	- 大数据Spark
	- 自动化运维测试
	- web开发
	- 机器学习
	- 胶水语言

- 基础语法

	- number
值类型，只读的不可变的

		- type(2//2) -> int  // 整除
		- 进制转换

			- 0b

				- bin()

			- 0o

				- oct()

			- 0x

				- hex()

			- demical

				- int()

		- bool

			- bool()
			- False

				- None
				- ''
				- {}
				- []
				- 0

		- complex

			- j

	- 序列(组)

		- 字符串 str
值类型，只读的不可变的

			- 不可变类型
			- '
			- "
			- '''  """ 多行字符
			- r
			- 操作

				- +
				- *3
				- [0:4] 4不包括
				- [4:1000]

			- ord(): 返回ascii值

		- tuple 元组: ()
值类型，只读的不可变的

			- 只读的不可变的

				- (1,2,[3,5,8])
嵌套拆分可变不可变部分

			- 定义只有一个元素: (1,)
			- 定义空: ()

		- list: []
引用类型，可变

			- 元素类型多种

		- 共有操作

			- 序号引用[index]
			- 切片: [0:8:2]
			- +
			- *
			- in
			- len()
			- max() / min()

				- 字符串编码高低

	- 无序列(组)
引用类型，可变

		- 集合set: {}

			- 元素不重复
			- 差集 -
			- 交集 &
			- 并集 |
			- 空集合: set()

		- 字典dict: {key:value}

			- key不重复, 值或者类型
			- key必须是不可变类型

	- 运算

		- 算数运算

			- +  
			- -  
			- *  
			- /  
			- //  
			- %  
			- **

		- 赋值运算符号

			- =
			- +=
			- *=
			- -=
			- /=
			- %=
			- **=
			- //=

		- 关系运算符

			- > < != ==
			- 从左到右逐个比较

				- "adc">"acb"
				- [1,2,3]<[2,4,5]

			- 类型

				- type(a)==int

					- 不能判断子类型

				- isinstance(a,int)
				- isinstance(a,(int,str))

		- 逻辑运算

			- and or not
			- 最少计算原则

		- 成员运算

			- in
			- 字典查找的是key值

		- 身份运算

			- is
			- 判断身份id是否相等: 内存地址
			- 不但判断值 还判断类型

		- 位运算

			- &按位与  |按位或  ^按位异或  ~按位取反  <<左移  >>右移
			- 转换成二进制再计算

		- 优先级

			- **	指数 (最高优先级)
			- ~ + -	按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)
			- * / % //	乘，除，取模和取整除
			- + -	加法减法
			- >> <<	右移，左移运算符
			- &	位 'AND'
			- ^ |	位运算符
			- <= < > >=	比较运算符
			- <> == !=	等于运算符
			- =  %=   /=   //=   -=   +=   *=   **=	赋值运算符
			- is      is not	身份运算符
			- in    not in	成员运算符
			- 逻辑运算符

				- not 	
				- and 
				- or

	- 表达式Expression

		- 运算符operator和操作数operand所构成的序列

	- 流程控制

		- 条件

			- if

		- 循环

			- while ... else

				- 递归

			- for ... else

				- 遍历 序列 集合 字典
				- break 之后不执行 else
				- range(0,10偏移量,2)
				- 切片a[0:len(a):3]

- 进阶

	- 高性能
	- 封装性好(可复用性)
	- 抽象能力

- python项目的组织结构

	- 包

		- 多个模块

			- 多个类 Class

				- 特性

					- 函数

						- 用途

							- 功能性
							- 隐藏细节
							- 复用

						- 定义

							- def
							- return 

								- Value/None
								- 多个值 

									- return a,b    元组
									- 避免依靠序号获取值

										- 序列解包: a,b =func()

											- a,b,c=1,2,3
											- a=b=c=1

							- 递归次数最大限制默认(995)

								- sys.setrecursionlimt(10000)

						- 参数

							- 必须参数

								- 形式参数
								- 实际参数

							- 关键字参数

								- 调用的时候指定形参赋值

							- 默认参数

								- 置后

							- 可变参数函数

								- *args

									- 数组参数
									- 匹配完定义好的参数，剩余的参数以元组的形式存储在 args（args 名称你可以自行定义）

								- **kwargs

									- 字典参数
									- 参数在函数内部将被存放在以形式名为标识符的 dictionary 中，这时调用函数的方法则需要采用 arg1=value1,arg2=value2 这样的形式
									- dict是传入参数的一份拷贝

								- 注意

									- 采用 **kwargs 传递参数的时候，你不能传递数组参数
									- db_conf = {user='xx',password='yy', host='xxx.xxx.xxx.xxx',database='zz'}
cnx = mysql.connector.connect(**db_conf)

					- 变量
(指针指向)

						- 命名可读性强
						- 字母数字下划线

							- _2

						- 不可变传值
可变传址
						- hex(id()):  获取内存地址

			- 物理存在: py文件
			- 文件名
			- 提取公用的部分为单独模块
			- 模块导入

				- import <命名空间.模块名> as <简化名>
import c7

					- 通过命名空间引用
c7.a
					- 不能直接使用模块下的变量

				- from <命名空间.模块名> import <函数/变量/*>

					- 直接使用
					- __all__=[可以导入的变量]

				- 导入模块时会执行所有代码

		- 物理存在: 文件夹
		- 文件夹名字为包名
		- __init__.py : 包的定义

			- 也是模块
			- 该模块的名字就是父文件夹的名字
			- 执行时机

				- 包被导入
				- 包内的模块被导入
				- --> 模块初始化

			- __all__ 指定哪些模块可以被导入

	- 命名空间: 路径
	- 常见错误

		- 包和模块是不会被重复导入的
		- 避免循环导入

- 面向对象

	- 对象的三个特征

		- value

			- ==

		- id

			- is

		- type

			- isinstance

	- 类!=面向对象
	- 类class

		- 作用: 封装
		- 现实世界或思维世界中的实体在计算机中的映射
封装数据及其操作
		- 首字母大写
		- 内部

			- 定义数据成员（特征）
			- 定义方法（行为）

				- 设计层面的称谓，函数是运行、过程式的称谓

			- 对应主体

		- 只描述定义，不执行
		- 构造函数  __init__(self)

			- 不能返回非None值
			- 生成不同的对象
			- 初始化对象的属性

		- 类方法

			- @classmethod
			- 操作类变量
			- cls

		- 类变量

			- 访问优先级低
			- 访问方法

				- 类内部

					- self.__class__.类变量
					- className.类变量

				- 类外部

					- className.类变量

	- 对象实例

		- 实例变量

			- 访问优先级高
			- 实例名.__dict__ 可获取所有实例变量

		- 实例方法

			- self

				- 可重命名
				- 代表实例主体
				- 显胜于隐

			- 操作实例变量

		- 可以调用类方法

- 备注

	- 每行少于80个字符

		- 换行方法

			- \
			- ()

	- pass 占位
	- 代码块
	- print( ,end='')
	- round(a,2)
	- 序列解包

- 误区
- vscode

	- files.exclude

## 人工智能

### 机器学习

- 表示学习(representation learning)
特征学习(feature learning)

  通过不同种类基本操作层的“堆叠”将原始数据表示（raw data representation）不经任何人为干预直接映射为高层语义表示（high-level semantic representation）并实现向任务目标映射的过程

	- 样本特征表示未知
端到端学习(end-to-end manner)

		- 深度学习DBN
Deep belief Network

			- 神经网络

				- 卷积Convolutional Neural Network(CNN)

				  模型的训练过程可以简单抽
				  象为原始数据向最终目标的直接“拟合”，而中间的这些部件正起到了将原始
				  数据映射为特征（即特征学习）随后再映射为样本标记（即目标任务，如分类）
				  的作用

					- 前馈运算feed-forward

						- 卷积层
						- 汇合层
						- 得到目标函数objective/cost/loss function

							- 数据损失data loss
							- 模型参数的正则化损失 regularization loss

					- 反馈运算

						- 计算损失loss
						- 反向传播算法error back-propagation algo
						- 随机梯度下降法 Stochastic Gradient Descent (SGD)

				- 循环神经网络 Recurrent Neural Network (RNN)

					- 长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN

						- 为了解决长序列训练过程中的问题

							- 梯度消失
							- 梯度爆炸

				- Multi Layer  MLP
				- boltzmann machine

	- 样本特征表示已知
人工特征

		- 特征选择算法
		- 分类器
		- 集成学习

- 特征工程 Feature engineering

	- 数据挖掘的工业界应用
	- 计算机视觉应用
	- 特征描述子

		- 全局特征描述子
		- 局部特征描述子

- 迁移学习 (Transfer Learning)

*XMind: ZEN - Trial Version*