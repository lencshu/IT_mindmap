<?xml version="1.0" encoding="UTF-8"?>
<opml version="1.0">
	<head>
		<dateCreated>Thu Mar 12 2020 00:24:10 GMT+0100 (罗马标准时间)</dateCreated>
		<dateModified>Thu Mar 12 2020 00:24:10 GMT+0100 (罗马标准时间)</dateModified>
	</head>
	<body>
		<outline text="IT">
			<outline text="概念">
				<outline text="计算机三大件">
					<outline text="存储"></outline>
					<outline text="IO"></outline>
					<outline text="CPU"></outline>
				</outline>
				<outline text="计算">
					<outline text="数据与算法"></outline>
					<outline text="状态与转移函数"></outline>
					<outline text="应用分类">
						<outline text="计算密集型应用"></outline>
						<outline text="数据密集型应用"></outline>
					</outline>
					<outline text="创造性">
						<outline text="数据模型"></outline>
						<outline text="数据流设计"></outline>
					</outline>
					<outline text="实际生产">
						<outline text="数据表就是数据结构"></outline>
						<outline text="索引与查询就是算法"></outline>
						<outline text="应用代码往往扮演的是胶水的角色">
							<outline text="处理IO与业务逻辑"></outline>
							<outline text="其他大部分工作都是在数据系统之间搬运数据"></outline>
						</outline>
					</outline>
				</outline>
				<outline text="抽象">
					<outline text="操作系统提供了对存储的基本抽象">
						<outline text="内存寻址空间"></outline>
						<outline text="磁盘逻辑块号"></outline>
					</outline>
					<outline text="文件系统提供了文件名到地址空间的KV存储抽象"></outline>
					<outline text="数据库提供了对应用通用存储需求的高级抽象"></outline>
				</outline>
			</outline>
			<outline text="人工智能">
				<outline text="机器学习">
					<outline text="表示学习(representation learning)
特征学习(feature learning)" _note="通过不同种类基本操作层的“堆叠”将原始数据表示（raw data representation）不经任何人为干预直接映射为高层语义表示（high-level semantic representation）并实现向任务目标映射的过程">
						<outline text="样本特征表示未知
端到端学习(end-to-end manner)">
							<outline text="深度学习DBN
Deep belief Network">
								<outline text="神经网络">
									<outline text="Multi Layer  MLP"></outline>
									<outline text="卷积Convolutional Neural Network(CNN)" _note="模型的训练过程可以简单抽&#10;象为原始数据向最终目标的直接“拟合”，而中间的这些部件正起到了将原始&#10;数据映射为特征（即特征学习）随后再映射为样本标记（即目标任务，如分类）&#10;的作用">
										<outline text="前馈运算feed-forward">
											<outline text="卷积层"></outline>
											<outline text="汇合层"></outline>
											<outline text="得到目标函数objective/cost/loss function">
												<outline text="数据损失data loss"></outline>
												<outline text="模型参数的正则化损失 regularization loss"></outline>
											</outline>
										</outline>
										<outline text="反馈运算">
											<outline text="计算损失loss"></outline>
											<outline text="反向传播算法error back-propagation algo"></outline>
											<outline text="随机梯度下降法 Stochastic Gradient Descent (SGD)"></outline>
										</outline>
									</outline>
									<outline text="循环神经网络 Recurrent Neural Network (RNN)">
										<outline text="概念">
											<outline text="长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN"></outline>
											<outline text="为了解决长序列训练过程中的问题">
												<outline text="梯度消失"></outline>
												<outline text="梯度爆炸"></outline>
											</outline>
										</outline>
									</outline>
									<outline text="boltzmann machine"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="样本特征表示已知
人工特征">
							<outline text="特征选择算法"></outline>
							<outline text="分类器"></outline>
							<outline text="集成学习"></outline>
						</outline>
					</outline>
					<outline text="特征工程 Feature engineering">
						<outline text="数据挖掘的工业界应用"></outline>
						<outline text="计算机视觉应用"></outline>
						<outline text="特征描述子">
							<outline text="全局特征描述子"></outline>
							<outline text="局部特征描述子"></outline>
						</outline>
					</outline>
					<outline text="迁移学习 (Transfer Learning)"></outline>
				</outline>
			</outline>
			<outline text="python">
				<outline text="Python 之禅"></outline>
				<outline text="特点">
					<outline text="易于上手 难于精通"></outline>
					<outline text="既有动态脚本的特性，又有面向对象的特点"></outline>
					<outline text="相对于C C++ java慢">
						<outline text="编译型">
							<outline text="C"></outline>
							<outline text="C++"></outline>
						</outline>
						<outline text="解释型">
							<outline text="JS"></outline>
							<outline text="python"></outline>
						</outline>
						<outline text="中间代码">
							<outline text="Java"></outline>
							<outline text=" C#"></outline>
						</outline>
					</outline>
					<outline text="开发效率和运行效率"></outline>
					<outline text="缺陷">
						<outline text="缺少类型检查"></outline>
					</outline>
				</outline>
				<outline text="用途">
					<outline text="爬虫"></outline>
					<outline text="大数据Spark"></outline>
					<outline text="自动化运维测试"></outline>
					<outline text="web开发"></outline>
					<outline text="机器学习"></outline>
					<outline text="胶水语言"></outline>
				</outline>
				<outline text="基础">
					<outline text="number
值类型，只读的不可变的">
						<outline text="type(2//2) -&gt; int  // 整除"></outline>
						<outline text="进制转换">
							<outline text="0b">
								<outline text="bin()"></outline>
							</outline>
							<outline text="0o">
								<outline text="oct()"></outline>
							</outline>
							<outline text="0x">
								<outline text="hex()"></outline>
							</outline>
							<outline text="demical">
								<outline text="int()"></outline>
							</outline>
						</outline>
						<outline text="bool">
							<outline text="bool()"></outline>
							<outline text="False">
								<outline text="None"></outline>
								<outline text="&apos;&apos;"></outline>
								<outline text="{}"></outline>
								<outline text="[]"></outline>
								<outline text="0"></outline>
							</outline>
						</outline>
						<outline text="complex">
							<outline text="j"></outline>
						</outline>
					</outline>
					<outline text="序列(组)">
						<outline text="字符串 str
值类型，只读的不可变的">
							<outline text="不可变类型"></outline>
							<outline text="&apos;"></outline>
							<outline text="&quot;"></outline>
							<outline text="&apos;&apos;&apos;  &quot;&quot;&quot; 多行字符"></outline>
							<outline text="r"></outline>
							<outline text="操作">
								<outline text="+"></outline>
								<outline text="*3"></outline>
								<outline text="[0:4] 4不包括"></outline>
								<outline text="[4:1000]"></outline>
							</outline>
							<outline text="ord(): 返回ascii值"></outline>
						</outline>
						<outline text="tuple 元组: ()
值类型，只读的不可变的">
							<outline text="只读的不可变的">
								<outline text="(1,2,[3,5,8])
嵌套拆分可变不可变部分"></outline>
							</outline>
							<outline text="定义只有一个元素: (1,)"></outline>
							<outline text="定义空: ()"></outline>
						</outline>
						<outline text="list: []
引用类型，可变">
							<outline text="元素类型多种"></outline>
						</outline>
						<outline text="共有操作">
							<outline text="序号引用[index]"></outline>
							<outline text="切片: [0:8:2]"></outline>
							<outline text="+"></outline>
							<outline text="*"></outline>
							<outline text="in"></outline>
							<outline text="len()"></outline>
							<outline text="max() / min()">
								<outline text="字符串编码高低"></outline>
							</outline>
						</outline>
					</outline>
					<outline text="无序列(组)
引用类型，可变">
						<outline text="集合set: {}">
							<outline text="元素不重复"></outline>
							<outline text="差集 -"></outline>
							<outline text="交集 &amp;"></outline>
							<outline text="并集 |"></outline>
							<outline text="空集合: set()"></outline>
						</outline>
						<outline text="字典dict: {key:value}">
							<outline text="key不重复, 值或者类型"></outline>
							<outline text="key必须是不可变类型"></outline>
						</outline>
					</outline>
					<outline text="运算">
						<outline text="算数运算">
							<outline text="+  "></outline>
							<outline text="-  "></outline>
							<outline text="*  "></outline>
							<outline text="/  "></outline>
							<outline text="//  "></outline>
							<outline text="%  "></outline>
							<outline text="**"></outline>
						</outline>
						<outline text="赋值运算符号">
							<outline text="="></outline>
							<outline text="+="></outline>
							<outline text="*="></outline>
							<outline text="-="></outline>
							<outline text="/="></outline>
							<outline text="%="></outline>
							<outline text="**="></outline>
							<outline text="//="></outline>
						</outline>
						<outline text="关系运算符">
							<outline text="&gt; &lt; != =="></outline>
							<outline text="从左到右逐个比较">
								<outline text="&quot;adc&quot;&gt;&quot;acb&quot;"></outline>
								<outline text="[1,2,3]&lt;[2,4,5]"></outline>
							</outline>
							<outline text="类型">
								<outline text="type(a)==int">
									<outline text="不能判断子类型"></outline>
								</outline>
								<outline text="isinstance(a,int)"></outline>
								<outline text="isinstance(a,(int,str))"></outline>
							</outline>
						</outline>
						<outline text="逻辑运算">
							<outline text="and or not"></outline>
							<outline text="最少计算原则"></outline>
						</outline>
						<outline text="成员运算">
							<outline text="in"></outline>
							<outline text="字典查找的是key值"></outline>
						</outline>
						<outline text="身份运算">
							<outline text="is"></outline>
							<outline text="判断身份id是否相等: 内存地址"></outline>
							<outline text="不但判断值 还判断类型"></outline>
						</outline>
						<outline text="位运算">
							<outline text="&amp;按位与  |按位或  ^按位异或  ~按位取反  &lt;&lt;左移  &gt;&gt;右移"></outline>
							<outline text="转换成二进制再计算"></outline>
						</outline>
						<outline text="优先级">
							<outline text="**	指数 (最高优先级)"></outline>
							<outline text="~ + -	按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)"></outline>
							<outline text="* / % //	乘，除，取模和取整除"></outline>
							<outline text="+ -	加法减法"></outline>
							<outline text="&gt;&gt; &lt;&lt;	右移，左移运算符"></outline>
							<outline text="&amp;	位 &apos;AND&apos;"></outline>
							<outline text="^ |	位运算符"></outline>
							<outline text="&lt;= &lt; &gt; &gt;=	比较运算符"></outline>
							<outline text="&lt;&gt; == !=	等于运算符"></outline>
							<outline text="=  %=   /=   //=   -=   +=   *=   **=	赋值运算符"></outline>
							<outline text="is      is not	身份运算符"></outline>
							<outline text="in    not in	成员运算符"></outline>
							<outline text="逻辑运算符">
								<outline text="not 	"></outline>
								<outline text="and "></outline>
								<outline text="or"></outline>
							</outline>
						</outline>
					</outline>
					<outline text="表达式Expression">
						<outline text="运算符operator和操作数operand所构成的序列"></outline>
					</outline>
					<outline text="流程控制">
						<outline text="条件">
							<outline text="if">
								<outline text="true false 对应关系">
									<outline text="false">
										<outline text="None"></outline>
										<outline text="&apos;&apos;"></outline>
										<outline text="[]"></outline>
									</outline>
									<outline text="true"></outline>
									<outline text="obj实例">
										<outline text="false">
											<outline text="__bool__():
return 0">
												<outline text="优先级更高"></outline>
												<outline text="True"></outline>
												<outline text="False"></outline>
											</outline>
											<outline text="__len__():
return 0">
												<outline text="true"></outline>
												<outline text="或者int"></outline>
											</outline>
										</outline>
										<outline text="跟实例是否存在没关系"></outline>
									</outline>
								</outline>
								<outline text="等同于用bool()"></outline>
							</outline>
						</outline>
						<outline text="循环">
							<outline text="while ... else">
								<outline text="递归"></outline>
							</outline>
							<outline text="for ... else">
								<outline text="遍历 序列 集合 字典"></outline>
								<outline text="break 之后不执行 else"></outline>
								<outline text="range(0,10偏移量,2)"></outline>
								<outline text="切片a[0:len(a):3]"></outline>
							</outline>
						</outline>
					</outline>
				</outline>
				<outline text="进阶">
					<outline text="高级设计">
						<outline text="高性能"></outline>
						<outline text="封装性好(可复用性)"></outline>
						<outline text="抽象能力"></outline>
					</outline>
					<outline text="python项目的组织结构">
						<outline text="包">
							<outline text="多个模块">
								<outline text="多个类 Class">
									<outline text="特性">
										<outline text="函数">
											<outline text="用途">
												<outline text="功能性"></outline>
												<outline text="隐藏细节"></outline>
												<outline text="复用"></outline>
											</outline>
											<outline text="定义">
												<outline text="def"></outline>
												<outline text="return ">
													<outline text="Value/None"></outline>
													<outline text="多个值 ">
														<outline text="return a,b    元组"></outline>
														<outline text="避免依靠序号获取值">
															<outline text="序列解包: a,b =func()">
																<outline text="a,b,c=1,2,3"></outline>
																<outline text="a=b=c=1"></outline>
															</outline>
														</outline>
													</outline>
												</outline>
												<outline text="递归次数最大限制默认(995)">
													<outline text="sys.setrecursionlimt(10000)"></outline>
												</outline>
											</outline>
											<outline text="参数">
												<outline text="必须参数">
													<outline text="形式参数"></outline>
													<outline text="实际参数"></outline>
												</outline>
												<outline text="关键字参数">
													<outline text="调用的时候指定形参赋值"></outline>
												</outline>
												<outline text="默认参数">
													<outline text="置后"></outline>
												</outline>
												<outline text="可变参数函数">
													<outline text="*args">
														<outline text="数组参数"></outline>
														<outline text="匹配完定义好的参数，剩余的参数以元组的形式存储在 args（args 名称你可以自行定义）"></outline>
													</outline>
													<outline text="**kwargs">
														<outline text="字典参数"></outline>
														<outline text="参数在函数内部将被存放在以形式名为标识符的 dictionary 中，这时调用函数的方法则需要采用 arg1=value1,arg2=value2 这样的形式"></outline>
														<outline text="dict是传入参数的一份拷贝"></outline>
													</outline>
													<outline text="注意">
														<outline text="采用 **kwargs 传递参数的时候，你不能传递数组参数"></outline>
														<outline text="db_conf = {user=&apos;xx&apos;,password=&apos;yy&apos;, host=&apos;xxx.xxx.xxx.xxx&apos;,database=&apos;zz&apos;}
cnx = mysql.connector.connect(**db_conf)"></outline>
													</outline>
												</outline>
											</outline>
										</outline>
										<outline text="变量
(指针指向)">
											<outline text="命名可读性强"></outline>
											<outline text="字母数字下划线">
												<outline text="_2"></outline>
											</outline>
											<outline text="不可变传值
可变传址"></outline>
											<outline text="hex(id()):  获取内存地址"></outline>
										</outline>
									</outline>
								</outline>
								<outline text="物理存在: py文件"></outline>
								<outline text="文件名"></outline>
								<outline text="提取公用的部分为单独模块"></outline>
								<outline text="模块导入">
									<outline text="import &lt;命名空间.模块名&gt; as &lt;简化名&gt;
import c7">
										<outline text="通过命名空间引用
c7.a"></outline>
										<outline text="不能直接使用模块下的变量"></outline>
									</outline>
									<outline text="from &lt;命名空间.模块名&gt; import &lt;函数/变量/*&gt;">
										<outline text="直接使用"></outline>
										<outline text="__all__=[可以导入的变量]"></outline>
									</outline>
									<outline text="导入模块时会执行所有代码"></outline>
								</outline>
							</outline>
							<outline text="物理存在: 文件夹"></outline>
							<outline text="文件夹名字为包名"></outline>
							<outline text="__init__.py : 包的定义">
								<outline text="也是模块"></outline>
								<outline text="该模块的名字就是父文件夹的名字"></outline>
								<outline text="执行时机">
									<outline text="包被导入"></outline>
									<outline text="包内的模块被导入"></outline>
									<outline text="--&gt; 模块初始化"></outline>
								</outline>
								<outline text="__all__ 指定哪些模块可以被导入"></outline>
							</outline>
						</outline>
						<outline text="命名空间: 路径"></outline>
						<outline text="常见错误">
							<outline text="包和模块是不会被重复导入的"></outline>
							<outline text="避免循环导入"></outline>
						</outline>
					</outline>
					<outline text="面向对象">
						<outline text="概念">
							<outline text="对象的三个特征">
								<outline text="value">
									<outline text="=="></outline>
								</outline>
								<outline text="id">
									<outline text="is"></outline>
								</outline>
								<outline text="type">
									<outline text="isinstance"></outline>
								</outline>
							</outline>
							<outline text="类!=面向对象"></outline>
						</outline>
						<outline text="类class">
							<outline text="概念">
								<outline text="作用: 封装"></outline>
								<outline text="现实世界或思维世界中的实体在计算机中的映射
封装数据及其操作"></outline>
								<outline text="首字母大写"></outline>
								<outline text="内部">
									<outline text="定义数据成员（特征）"></outline>
									<outline text="定义方法（行为）">
										<outline text="设计层面的称谓，函数是运行、过程式的称谓"></outline>
									</outline>
									<outline text="对应主体"></outline>
								</outline>
								<outline text="只描述定义，不执行"></outline>
							</outline>
							<outline text="构造函数  __init__(self)">
								<outline text="不能返回非None值"></outline>
								<outline text="生成不同的对象"></outline>
								<outline text="初始化对象的属性"></outline>
							</outline>
							<outline text="类方法">
								<outline text="@classmethod"></outline>
								<outline text="操作类变量">
									<outline text="cls.类变量"></outline>
								</outline>
								<outline text="cls"></outline>
								<outline text="不要用实例调用类方法，虽然可行"></outline>
							</outline>
							<outline text="类变量">
								<outline text="访问优先级低"></outline>
								<outline text="访问变量">
									<outline text="类内部">
										<outline text="self.__class__.类变量"></outline>
										<outline text="className.类变量"></outline>
									</outline>
									<outline text="类外部">
										<outline text="className.类变量"></outline>
									</outline>
								</outline>
							</outline>
							<outline text="静态方法">
								<outline text="@staticmethod"></outline>
								<outline text="对象和类都可调用"></outline>
								<outline text="访问变量">
									<outline text="类变量可以">
										<outline text="className.类变量"></outline>
									</outline>
									<outline text="实例变量不可"></outline>
								</outline>
								<outline text="类似函数，跟类和实例关系不大"></outline>
							</outline>
							<outline text="调用类方法">
								<outline text="类名.实例方法(实例名,实例参数)
实例名占用self的位置"></outline>
							</outline>
						</outline>
						<outline text="对象实例">
							<outline text="调用类方法可行，但不要用"></outline>
							<outline text="实例变量">
								<outline text="访问优先级高"></outline>
								<outline text="实例名.__dict__ 可获取所有实例变量"></outline>
							</outline>
							<outline text="实例方法">
								<outline text="self">
									<outline text="可重命名"></outline>
									<outline text="代表实例主体"></outline>
									<outline text="显胜于隐"></outline>
								</outline>
								<outline text="操作实例变量"></outline>
							</outline>
						</outline>
						<outline text="成员可见性">
							<outline text="概念">
								<outline text="变量和方法的可见性"></outline>
								<outline text="内外之分">
									<outline text="对象.方法: 外部调用"></outline>
									<outline text="self.方法: 外部调用"></outline>
								</outline>
								<outline text="数据安全">
									<outline text="只通过调用方法来内部修改变量"></outline>
									<outline text="加判断"></outline>
								</outline>
							</outline>
							<outline text="公开public和私有private">
								<outline text="用 __ 开头但不用其结尾的成员都是私有的"></outline>
								<outline text="外部用 实例.__variable 调用时， 是生成了新的实例变量"></outline>
							</outline>
						</outline>
						<outline text="3大特性">
							<outline text="继承性">
								<outline text="概念">
									<outline text="继承父类的所有"></outline>
									<outline text="子类可以继承多个父类"></outline>
									<outline text="避免重复的方法和变量"></outline>
									<outline text="一个模块一个类"></outline>
								</outline>
								<outline text="class ***(父类)"></outline>
								<outline text="调用父类方法
(构造函数为例)">
									<outline text="传入全部父子参数"></outline>
									<outline text="父类参数传递">
										<outline text="1. 父类.__init__(self,父类参数)"></outline>
										<outline text="2. super(当前类,self).__init__(父类参数)"></outline>
									</outline>
								</outline>
							</outline>
							<outline text="封装性"></outline>
							<outline text="多态性"></outline>
						</outline>
					</outline>
					<outline text="正则表达式">
						<outline text="概念">
							<outline text="一个特殊的字符序列，判断一个字符串是否与设定相匹配"></outline>
							<outline text="关键在于规则"></outline>
						</outline>
						<outline text="查找字符串模块">
							<outline text="1. a.index(&quot;python&quot;)&gt;-1"></outline>
							<outline text="2. &quot;python&quot; in a"></outline>
							<outline text="3. 正则re模块">
								<outline text="findall(pattern, rep, flag)">
									<outline text="import re"></outline>
									<outline text="if len(列表) &gt; 0"></outline>
									<outline text="re.findall(&quot;正则表达式&quot;,a, flag) ">
										<outline text="返回列表"></outline>
										<outline text="flag">
											<outline text="re.I : 忽略大小写"></outline>
											<outline text="re.S : 匹配所有字符 "></outline>
											<outline text="多个flag同时满足: re.I | re.S">
												<outline text="re.findall(&quot;c.{1}&quot;, string, re.S)"></outline>
											</outline>
										</outline>
									</outline>
								</outline>
								<outline text="sub(pattern, rep, string, count, flag)">
									<outline text="与replace区别">
										<outline text="string.replace(): string 不可变"></outline>
									</outline>
									<outline text="rep可以为函数">
										<outline text="匹配到的结果obj作为参数传入函数"></outline>
										<outline text="matched = value.group()"></outline>
										<outline text="可以加入if else 判断"></outline>
										<outline text="return 字符串格式"></outline>
									</outline>
									<outline text="子主题 3"></outline>
								</outline>
								<outline text="search">
									<outline text="搜索整个字符串直到找到第一个"></outline>
								</outline>
								<outline text="match">
									<outline text="从字符串首字母开始匹配"></outline>
								</outline>
							</outline>
							<outline text="group ">
								<outline text="对应search和match返回的obj"></outline>
								<outline text="findall直接返回结果"></outline>
								<outline text="用单词定界: life(.*)python"></outline>
								<outline text="获取life和python之间的字符串: group(1)"></outline>
								<outline text="group(0): 获取完整字符串">
									<outline text="1: 获取第一对()之间的字符串"></outline>
									<outline text="2: 获取第二对()之间的字符串"></outline>
									<outline text="group(0,1,2)"></outline>
									<outline text="groups(): 返回之间的字符串tuple"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="元字符规则">
							<outline text="字符集(查找任意字符)">
								<outline text="a[cf]c ">
									<outline text="匹配afc或者acc"></outline>
									<outline text="普通字符用于定界"></outline>
								</outline>
								<outline text="a[^cf]c ">
									<outline text="取反"></outline>
								</outline>
								<outline text="a[c-f]c ">
									<outline text="匹配c到f"></outline>
								</outline>
							</outline>
							<outline text="概况字符集">
								<outline text="数字 \d  &lt;-&gt;  [0-9]"></outline>
								<outline text="非数字 \D  &lt;-&gt;  [^0-9]"></outline>
								<outline text="单词字符 \w  &lt;-&gt;  [A-Za-z0-9_]"></outline>
								<outline text="非单词字符\W">
									<outline text="空格"></outline>
									<outline text="&amp;"></outline>
									<outline text="\t  \n  \r"></outline>
								</outline>
								<outline text="空白字符  \s">
									<outline text="空格回车换行Tab"></outline>
								</outline>
								<outline text="非空白字符 \S"></outline>
								<outline text=". ">
									<outline text="匹配除换行符\n之外的所有字符"></outline>
								</outline>
							</outline>
							<outline text="数量词">
								<outline text="构成">
									<outline text="字符集{n,m}">
										<outline text="n: 最少字符数"></outline>
										<outline text="m: 最多字符数(可选)"></outline>
									</outline>
									<outline text="python*">
										<outline text="字符n可出现0次或者无限多次"></outline>
									</outline>
									<outline text="python+">
										<outline text="字符n可出现1次或者无限多次"></outline>
									</outline>
									<outline text="python?">
										<outline text="字符n可出现0次或者1次"></outline>
									</outline>
								</outline>
								<outline text="贪婪非贪婪">
									<outline text="默认贪婪模式"></outline>
									<outline text="字符集{n,m}?">
										<outline text="?前面是个范围"></outline>
									</outline>
								</outline>
								<outline text="边界匹配">
									<outline text="从开头匹配">
										<outline text="^"></outline>
									</outline>
									<outline text="从结尾匹配">
										<outline text="$"></outline>
									</outline>
								</outline>
								<outline text="字符串组">
									<outline text="(string){3}: string 重复3次"></outline>
									<outline text="() 字符之间是且关系"></outline>
									<outline text="[] 字符之间是或关系"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="常用"></outline>
					</outline>
					<outline text="json">
						<outline text="概念">
							<outline text="javascript object notation"></outline>
							<outline text="轻量级数据交换格式"></outline>
							<outline text="字符串是表现形式"></outline>
							<outline text="xml"></outline>
							<outline text="优势">
								<outline text="易读"></outline>
								<outline text="容易解析，跨语言数据交换">
									<outline text="调用服务"></outline>
								</outline>
								<outline text="网络传输效率高"></outline>
							</outline>
							<outline text="在js中是object"></outline>
							<outline text="误区">
								<outline text="概念区分">
									<outline text="json对象">
										<outline text="只在js里面成立"></outline>
									</outline>
									<outline text="json">
										<outline text="中间数据类型"></outline>
										<outline text="有自己的数据类型，和js类似"></outline>
										<outline text="rest服务"></outline>
									</outline>
									<outline text="json字符串"></outline>
								</outline>
								<outline text="js是ecma标准的实现，json是ecma定义的标准实现"></outline>
								<outline text="js actionscript typescript json 平级"></outline>
							</outline>
						</outline>
						<outline text="应用场景">
							<outline text="前后端交互"></outline>
						</outline>
						<outline text="反序列化">
							<outline text="json.loads">
								<outline text="obj转成dict"></outline>
								<outline text="array转成list"></outline>
								<outline text="null -&gt; None"></outline>
							</outline>
							<outline text="字符串key和value加双引号"></outline>
						</outline>
						<outline text="序列化">
							<outline text="json.dumps"></outline>
						</outline>
					</outline>
					<outline text="枚举类">
						<outline text="概念">
							<outline text="显示字符而不是实际值"></outline>
							<outline text="枚举不能改"></outline>
							<outline text="不能用 &gt; &lt; 比较, 但可比较身份is 与 ="></outline>
							<outline text="for遍历可获取所有的枚举类型"></outline>
							<outline text="值相等的话 相当于创建了别名">
								<outline text="遍历的时候别名不存在"></outline>
								<outline text="需要用 VIP.__members__.items() 或者VIP.__members__"></outline>
							</outline>
							<outline text="枚举是单例模式(23种设计模式之一)"></outline>
						</outline>
						<outline text="用法">
							<outline text="from enum import Enum">
								<outline text="IntEnum: 整型枚举"></outline>
								<outline text="unique">
									<outline text="@unique  加装饰器确保值唯一"></outline>
								</outline>
							</outline>
							<outline text="class VIP(Enum):"></outline>
							<outline text="yellow = 1"></outline>
							<outline text="获取数值">
								<outline text="VIP.yellow.value"></outline>
							</outline>
							<outline text="获取枚举名称">
								<outline text="VIP.yellow.name   返回字符串"></outline>
							</outline>
							<outline text="VIP.yellow == VIP[&apos;yellow&apos;]"></outline>
						</outline>
						<outline text="通过值查找枚举名">
							<outline text="VIP(a)"></outline>
						</outline>
						<outline text="定义枚举的其他方法">
							<outline text="全局变量"></outline>
							<outline text="类"></outline>
							<outline text="字典"></outline>
						</outline>
					</outline>
				</outline>
				<outline text="高阶">
					<outline text="概括">
						<outline text="只开发业务逻辑，不考虑太多的封装性"></outline>
						<outline text="更适用于包，类库的开发者"></outline>
					</outline>
					<outline text="函数">
						<outline text="其他语言中函数只是一段可执行的代码"></outline>
						<outline text="python中的函数也是对象"></outline>
						<outline text="可以把函数赋值给变量"></outline>
						<outline text="函数可以作为参数传入另一个函数"></outline>
						<outline text="函数也能作为返回结果"></outline>
					</outline>
					<outline text="函数式编程">
						<outline text="概念">
							<outline text="没有明确的定义，根据语言变化"></outline>
							<outline text="应该淡化概念"></outline>
							<outline text="流程控制">
								<outline text="命令式编程">
									<outline text="函数"></outline>
									<outline text="条件"></outline>
									<outline text="循环"></outline>
								</outline>
								<outline text="函数式编程">
									<outline text="map"></outline>
									<outline text="filter"></outline>
									<outline text="reduce"></outline>
									<outline text="算子: lambda"></outline>
								</outline>
							</outline>
							<outline text="lisp 函数式编程鼻祖">
								<outline text="人工智能"></outline>
							</outline>
						</outline>
						<outline text="闭包">
							<outline text="例子">
								<outline text="def a():
    a=25
    def b(x):
         return a*x*x
     return b"></outline>
							</outline>
							<outline text="概念">
								<outline text="定义: 函数及其环境变量"></outline>
								<outline text="局部变量按照层级由低到高查找"></outline>
								<outline text="避免使用全局变量"></outline>
								<outline text="所有操作都是在函数内部"></outline>
								<outline text="工厂模式"></outline>
								<outline text="各语言区别">
									<outline text="python强调环境变量"></outline>
									<outline text="js 在函数外部调用函数内部的变量">
										<outline text="父函数中定义的变量"></outline>
										<outline text="没有nonlocal"></outline>
										<outline text="常驻内存引起浏览器卡顿"></outline>
									</outline>
								</outline>
								<outline text="缺陷">
									<outline text="环境变量常驻内存可能会导致泄露"></outline>
								</outline>
							</outline>
							<outline text="环境变量">
								<outline text="保存位置: f.__closure__"></outline>
								<outline text="取用： f.__closure__[0].cell_contents"></outline>
							</outline>
							<outline text="全局变量=局部变量 会报错">
								<outline text="origin = new_pos"></outline>
								<outline text="需要加 global关键字"></outline>
							</outline>
							<outline text="用法">
								<outline text="1. 定义子函数"></outline>
								<outline text="2.子函数中用nonlocal定义环境变量"></outline>
								<outline text="3. 父函数返回子函数名(不带括号)"></outline>
								<outline text="调用">
									<outline text="1.先用父函数初始化并定义为新变量">
										<outline text="类似于初始化实例"></outline>
										<outline text="父函数(父参数)(子参数)"></outline>
									</outline>
									<outline text="2.新变量传参调用"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="lambda+map">
							<outline text="不会提升运行效率"></outline>
							<outline text="匿名函数(lambda表达式)">
								<outline text="用法">
									<outline text="lambda 参数: 返回结果表达式">
										<outline text="只能返回表达式，不能是代码块"></outline>
										<outline text="不能进行赋值操作"></outline>
									</outline>
									<outline text="赋值给一个变量来调用"></outline>
								</outline>
								<outline text="三元表达式">
									<outline text="其他语言: 条件? 是:否"></outline>
									<outline text="条件为真返回的结果  if  条件 else 条件为假返回结果"></outline>
								</outline>
							</outline>
							<outline text="map 类">
								<outline text="概念">
									<outline text="映射"></outline>
								</outline>
								<outline text="用法">
									<outline text="map(函数，可变序列/集合)"></outline>
									<outline text="返回map对象">
										<outline text="list()转换"></outline>
									</outline>
								</outline>
							</outline>
							<outline text="结合用法">
								<outline text="map(lambda 参数: 结果表达式, *可变序列)">
									<outline text="序列个数等于参数个数"></outline>
									<outline text="返回序列个数等于最小序列长度"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="reduce函数">
							<outline text="概念">
								<outline text="连续传入序列中的元素调用函数参数"></outline>
								<outline text="将返回结果作为参数之一参与调用"></outline>
							</outline>
							<outline text="用法">
								<outline text="from functools import reduce"></outline>
								<outline text="reduce(lambda x,y:x+y, 序列，函数参数x的初始值)"></outline>
							</outline>
						</outline>
						<outline text="大数据的计算模型map/reduce">
							<outline text="场景">
								<outline text="并行计算"></outline>
							</outline>
							<outline text="map">
								<outline text="映射"></outline>
							</outline>
							<outline text="reduce">
								<outline text="归约"></outline>
							</outline>
						</outline>
						<outline text="filter类">
							<outline text="filter(判断真假的lambda表达式, 集合X)"></outline>
							<outline text="只返回为真的数据，假的数据被剔除掉"></outline>
						</outline>
					</outline>
					<outline text="装饰器">
						<outline text="概念">
							<outline text="设计模式">
								<outline text="AOP编程思想"></outline>
							</outline>
							<outline text="对修改是封闭的，对扩展开放">
								<outline text="需求变更 不改函数"></outline>
							</outline>
							<outline text="函数作为参数传入">
								<outline text="不能函数本身的特性"></outline>
								<outline text="不能体现关联性"></outline>
							</outline>
							<outline text="嵌套函数"></outline>
						</outline>
						<outline text="用法">
							<outline text="@语法糖">
								<outline text="改变写法"></outline>
							</outline>
							<outline text="原函数重新封装并执行，不改变调用 decorter(func)(fun参数)">
								<outline text="多参数">
									<outline text="wrapper(*args)"></outline>
									<outline text="func(*args)"></outline>
								</outline>
								<outline text="关键字参数 **kw">
									<outline text="wrapper(*args,**kw)"></outline>
									<outline text="func(*args,**kw)"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="高级">
							<outline text="代码稳定"></outline>
							<outline text="代码复用"></outline>
						</outline>
					</outline>
					<outline text="字典映射switch语句">
						<outline text="定义字典">
							<outline text="value可以对应函数"></outline>
						</outline>
						<outline text="获取方式 dict.get(key, default)">
							<outline text="容错"></outline>
						</outline>
					</outline>
					<outline text="[列表推导式]/{集合推导式}/字典推导式/(元组)">
						<outline text="[ i**2 for i in a if xxx]"></outline>
						<outline text="字典推导式">
							<outline text="{key for key,value in dict.items()}"></outline>
						</outline>
					</outline>
				</outline>
				<outline text="超阶
异步IO并发">
					<outline text="一切皆对象
一切都继承自object
一切都实例于type">
						<outline text="概念">
							<outline text="静态语言和动态语言的区别">
								<outline text="比java更彻底"></outline>
							</outline>
							<outline text="函数、类Class是对象，是python的一等公民。代码和模块也是对象">
								<outline text="概念">
									<outline text="类是模板对象"></outline>
								</outline>
								<outline text="特性">
									<outline text="1. 赋值给一个变量"></outline>
									<outline text="2.添加到集合对象中">
										<outline text="append到列表里"></outline>
									</outline>
									<outline text="3.可以作为参数传递给函数">
										<outline text="装饰器的基本原理"></outline>
									</outline>
									<outline text="4.可以当作函数的返回值"></outline>
								</outline>
							</outline>
							<outline text="元编程"></outline>
						</outline>
						<outline text="type object class">
							<outline text="type">
								<outline text="用法">
									<outline text="返回对象类型"></outline>
									<outline text="生成一个类">
										<outline text="type 生成int，int生成1"></outline>
									</outline>
								</outline>
								<outline text="本身是一个类，同时也是个对象">
									<outline text="type.__bases__ 是object"></outline>
								</outline>
								<outline text="object.__bases__ 为object"></outline>
								<outline text="type是自身的实例">
									<outline text="通过指针实现"></outline>
								</outline>
							</outline>
							<outline text="object">
								<outline text="object.__bases__ 为空"></outline>
								<outline text="type(object) 是 type"></outline>
							</outline>
							<outline text="关系">
								<outline text="type-&gt;class-&gt;obj"></outline>
								<outline text="object是所有class需要继承的基类,最顶层的基类">
									<outline text=".__bases__"></outline>
								</outline>
								<outline text="类对象">
									<outline text="类本身创建后不能修改"></outline>
									<outline text="对象化后可以修改"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="内置类型">
							<outline text="对象的三个特征">
								<outline text="身份">
									<outline text="id()  : 内存地址"></outline>
								</outline>
								<outline text="类型"></outline>
								<outline text="值"></outline>
							</outline>
							<outline text="None ：全局只有一个"></outline>
							<outline text="数值">
								<outline text="int"></outline>
								<outline text="float"></outline>
								<outline text="complex"></outline>
								<outline text="bool"></outline>
							</outline>
							<outline text="迭代类型"></outline>
							<outline text="生成器类型"></outline>
							<outline text="序列">
								<outline text="list"></outline>
								<outline text="bytes, bytearray, memoryview二进制序列 "></outline>
								<outline text="range"></outline>
								<outline text="tuple"></outline>
								<outline text="str"></outline>
								<outline text="array"></outline>
							</outline>
							<outline text="映射dict"></outline>
							<outline text="集合">
								<outline text="set"></outline>
								<outline text="frozenset"></outline>
							</outline>
							<outline text="上下文管理器类型(with)"></outline>
							<outline text="其他 深度原理">
								<outline text="模块类型"></outline>
								<outline text="class和实例"></outline>
								<outline text="函数"></outline>
								<outline text="方法"></outline>
								<outline text="代码"></outline>
								<outline text="object对象"></outline>
								<outline text="type"></outline>
								<outline text="ellipsis(省略号)"></outline>
								<outline text="notiimplemented"></outline>
							</outline>
						</outline>
					</outline>
					<outline text="魔法函数">
						<outline text="概念">
							<outline text="python中 以双下划线开头和结尾的自定义的"></outline>
							<outline text="为了增强类的特性"></outline>
						</outline>
						<outline text="迭代属性:  ">
							<outline text="__iter__"></outline>
							<outline text="序列类型">
								<outline text="__getitem__
return self.employee[item]">
									<outline text="for循环: for i in className"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="数据模型及其影响">
							<outline text="赋予类某些内置类型的特性"></outline>
						</outline>
						<outline text="函数调用顺序">
							<outline text="for">
								<outline text="__iter__"></outline>
								<outline text="__getitem__"></outline>
							</outline>
							<outline text="len">
								<outline text="__len__"></outline>
								<outline text="__getitem__"></outline>
							</outline>
						</outline>
						<outline text="类型">
							<outline text="非数学运算">
								<outline text="字符串表示">
									<outline text="__repr__">
										<outline text="开放模式下调用"></outline>
									</outline>
									<outline text="__str__">
										<outline text="字符串格式化输出"></outline>
									</outline>
								</outline>
								<outline text="集合序列相关">
									<outline text="__len__"></outline>
									<outline text="__getitem__"></outline>
									<outline text="__setitem__"></outline>
									<outline text="__delitem__"></outline>
									<outline text="__contains__"></outline>
								</outline>
								<outline text="迭代相关">
									<outline text="__iter__"></outline>
									<outline text="__next__"></outline>
								</outline>
								<outline text="可调用">
									<outline text="__call__"></outline>
								</outline>
								<outline text="with上下文管理器">
									<outline text="__enter__"></outline>
									<outline text="__exit__"></outline>
								</outline>
								<outline text="数值转换">
									<outline text="__abs__"></outline>
									<outline text="__bool__"></outline>
									<outline text="__int__"></outline>
									<outline text="__float__"></outline>
									<outline text="__hash__"></outline>
									<outline text="__index__"></outline>
								</outline>
								<outline text="元类相关">
									<outline text="__new__"></outline>
									<outline text="__init__"></outline>
								</outline>
								<outline text="属性相关">
									<outline text="__getattr__   __setattr__"></outline>
									<outline text="__getattribute__   __setattribute__"></outline>
									<outline text="__dir__"></outline>
								</outline>
								<outline text="属性描述符">
									<outline text="__get__"></outline>
									<outline text="__set__"></outline>
									<outline text="__delete__"></outline>
								</outline>
								<outline text="协程">
									<outline text="__await__"></outline>
									<outline text="__aiter__"></outline>
									<outline text="__anext__"></outline>
									<outline text="__aenter__"></outline>
									<outline text="__aexit__"></outline>
								</outline>
							</outline>
							<outline text="数学运算">
								<outline text="一元运算符">
									<outline text="__neg__（-）、__pos__（+）、__abs__"></outline>
								</outline>
								<outline text="二元运算符">
									<outline text="__lt__(&lt;)、 __le__ &lt;= 、 __eq__ == 、 __ne__ != 、 __gt__ &gt; 、 __ge__ &gt;="></outline>
								</outline>
								<outline text="算术运算符">
									<outline text="__add__ + 、 __sub__ - 、 __mul__ * 、 __truediv__ / 、 __floordiv__ // 、 __
mod__ % 、 __divmod__ divmod() 、 __pow__ ** 或 pow() 、 __round__ round()"></outline>
								</outline>
								<outline text="反向算术运算符">
									<outline text="__radd__ 、 __rsub__ 、 __rmul__ 、 __rtruediv__ 、 __rfloordiv__ 、 __rmod__ 、
__rdivmod__ 、 __rpow__"></outline>
								</outline>
								<outline text="增量赋值算术运算符">
									<outline text="__iadd__ 、 __isub__ 、 __imul__ 、 __itruediv__ 、 __ifloordiv__ 、 __imod__ 、
__ipow__"></outline>
								</outline>
								<outline text="位运算符">
									<outline text="__invert__ ~ 、 __lshift__ &lt;&lt; 、 __rshift__ &gt;&gt; 、 __and__ &amp; 、 __or__ | 、 __
xor__ ^"></outline>
								</outline>
								<outline text="反向位运算符">
									<outline text="__rlshift__ 、 __rrshift__ 、 __rand__ 、 __rxor__ 、 __ror__"></outline>
								</outline>
								<outline text="增量赋值位运算符">
									<outline text="__ilshift__ 、 __irshift__ 、 __iand__ 、 __ixor__ 、 __ior__"></outline>
								</outline>
							</outline>
						</outline>
					</outline>
					<outline text="第四章 深入类和对象">
						<outline text="4.1 鸭子类型和多态"></outline>
						<outline text="4.2 抽象基类(abc模块)"></outline>
						<outline text="4.3 使用isintance而不是type"></outline>
						<outline text="4.4 类变量和对象变量"></outline>
						<outline text="4.5 类属性和实例属性以及查找顺序"></outline>
						<outline text="4.6 静态方法、类方法以及对象方法"></outline>
						<outline text="4.7 数据封装和私有属性"></outline>
						<outline text="4.8 python对象的自省机制"></outline>
						<outline text="4.9 super函数"></outline>
						<outline text="4.10 django rest framework中对多继承使用的经验"></outline>
						<outline text="4.11 python中的with语句"></outline>
						<outline text="4.12 contextlib实现上下文管理器"></outline>
						<outline text="4.13 本章小结"></outline>
					</outline>
					<outline text="第五章 自定义序列类">
						<outline text="5.1 序列类型的分类">
							<outline text="容器序列">
								<outline text="list、tuple、deque"></outline>
							</outline>
							<outline text="扁平序列">
								<outline text="str、bytes、bytearray、array.array"></outline>
							</outline>
							<outline text="可变序列">
								<outline text="list， deque，bytearray、array"></outline>
							</outline>
							<outline text="不可变">
								<outline text="str、tuple、bytes"></outline>
							</outline>
						</outline>
						<outline text="5.2 序列的abc继承关系"></outline>
						<outline text="5.3 序列的+、+=和extend的区别"></outline>
						<outline text="5.4 实现可切片的对象"></outline>
						<outline text="5.5 bisect管理可排序序列"></outline>
						<outline text="5.6 什么时候我们不该用列表"></outline>
						<outline text="5.7 列表推导式、生成器表达式、字典推导式"></outline>
						<outline text="5.8 本章小结"></outline>
					</outline>
					<outline text="第六章 深入python的set和dict">
						<outline text="6.1 先来看看collections中的abc"></outline>
						<outline text="6.2 dict的常见用法">
							<outline text="setdefault"></outline>
							<outline text="defaultdict"></outline>
							<outline text="__missing__方法"></outline>
						</outline>
						<outline text="6.3 dict的子类">
							<outline text="defaultdict"></outline>
							<outline text="Counter"></outline>
							<outline text="不要去继承内置类型， 有可能会失败比如update方法"></outline>
						</outline>
						<outline text="6.4 set和frozenset"></outline>
						<outline text="6.5 dict和set实现原理"></outline>
						<outline text="6.6 本章小结"></outline>
					</outline>
					<outline text="第七章 对象引用、可变性和垃圾回收">
						<outline text="7.1 python变量到底是什么"></outline>
						<outline text="7.2 ==和is的区别"></outline>
						<outline text="7.3 del语句和垃圾回收"></outline>
						<outline text="7.4 一个经典的错误"></outline>
						<outline text="7.5 本章小结"></outline>
					</outline>
					<outline text="第八章 元类编程">
						<outline text="8.1 property动态属性"></outline>
						<outline text="8.2 __getattr__、__getattribute__魔法函数"></outline>
						<outline text="8.3 属性描述符和属性查找过程"></outline>
						<outline text="8.4 __new__和__init__的区别"></outline>
						<outline text="8.5 自定义元类"></outline>
						<outline text="8.6 元类实现简单的orm"></outline>
						<outline text="8.7 本章小结"></outline>
					</outline>
					<outline text="迭代器和生成器">
						<outline text="迭代器">
							<outline text="概念">
								<outline text="访问集合内元素的一种方式，一般用来遍历数据"></outline>
								<outline text="与list以下标访问的方式不同, []  list   __iter__"></outline>
								<outline text="迭代器不能返回"></outline>
								<outline text="惰性访问方式"></outline>
							</outline>
							<outline text="迭代协议">
								<outline text="from collections.abc import Iterable, Iterator"></outline>
								<outline text="class Iterable (metaclass=ABCMeta)"></outline>
							</outline>
							<outline text="9.1 python的迭代协议"></outline>
							<outline text="9.2 什么是迭代器和可迭代对象"></outline>
							<outline text="9.3 生成器函数使用"></outline>
							<outline text="9.4 生成器的原理"></outline>
							<outline text="9.5 通过UserList来看生成器的应用"></outline>
							<outline text="9.6 生成器实现大文件读取"></outline>
							<outline text="9.7 本章小结"></outline>
						</outline>
					</outline>
					<outline text="socket编程">
						<outline text="基础">
							<outline text="参考书">
								<outline text="TCP/IP详解"></outline>
							</outline>
							<outline text="5/7层OSI模型">
								<outline text="应用层 通过端口来区分应用">
									<outline text="HTTP"></outline>
									<outline text="FTP"></outline>
									<outline text="DNS"></outline>
									<outline text="SMTP"></outline>
								</outline>
								<outline text="传输层">
									<outline text="TCP"></outline>
									<outline text="UDP"></outline>
								</outline>
								<outline text="会话层/协议层"></outline>
								<outline text="网络层">
									<outline text="ip"></outline>
									<outline text="icmp"></outline>
								</outline>
								<outline text="数据链路层">
									<outline text="arp"></outline>
								</outline>
								<outline text="物理层">
									<outline text="100base"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="socket">
							<outline text="概念">
								<outline text="连接应用和传输层"></outline>
								<outline text="直接跟TCP打交道"></outline>
								<outline text="实现自己的协议"></outline>
								<outline text="双向的"></outline>
							</outline>
							<outline text="server">
								<outline text="随时监听的状态"></outline>
								<outline text="流程">
									<outline text="socket"></outline>
									<outline text="bind(协议，ip，端口)"></outline>
									<outline text="listen(客户端连接请求)"></outline>
									<outline text="accept: 阻塞等待连接请求(新套接字)"></outline>
									<outline text="recv"></outline>
									<outline text="send"></outline>
									<outline text="close"></outline>
								</outline>
							</outline>
							<outline text="client">
								<outline text="流程">
									<outline text="socket"></outline>
									<outline text="connect"></outline>
									<outline text="send"></outline>
									<outline text="recv"></outline>
									<outline text="close"></outline>
								</outline>
							</outline>
							<outline text="C/S通信">
								<outline text="socket发送http请求">
									<outline text="写类模拟urllib类"></outline>
								</outline>
								<outline text="urllib和socket区别">
									<outline text="urllib支持client，但是socket支持server、client等等"></outline>
									<outline text="urllib支持http、ftp等协议属于应用层是包装过socket的"></outline>
									<outline text="学习socket的目的不是为了让大家在任何时候都用socket去编程，而是要知道底层后期理解协程容易、以及具体问题在解决的时候首先能想到还有socket底层可以用"></outline>
								</outline>
							</outline>
						</outline>
						<outline text="10.3 socket实现聊天和多用户连接"></outline>
						<outline text="10.4 socket模拟http请求"></outline>
					</outline>
					<outline text="第十一章 多线程、多进程和线程池编程">
						<outline text="11.1 python中的GIL"></outline>
						<outline text="11.2 python多线程编程"></outline>
						<outline text="11.3 线程间通信-Queue"></outline>
						<outline text="11.4 线程同步（Lock、RLock、Semaphores、Condition）"></outline>
						<outline text="11.5 concurrent线程池编码"></outline>
						<outline text="11.6 多进程编程-multiprocessing"></outline>
						<outline text="11.7 进程间通信"></outline>
						<outline text="11.8 本章小结"></outline>
					</outline>
					<outline text="第十二章 协程和异步io">
						<outline text="12.1 并发、并行、同步、异步、阻塞、非阻塞"></outline>
						<outline text="12.2 C10K问题和io多路复用(select、poll、epoll)"></outline>
						<outline text="12.3 epoll+回调+事件循环方式url"></outline>
						<outline text="12.4 回调之痛"></outline>
						<outline text="12.5 C10M问题和协程"></outline>
						<outline text="12.6 生成器的send和yield from"></outline>
						<outline text="12.7 生成器如何变成协程？"></outline>
						<outline text="12.8 async和await原生协程"></outline>
						<outline text="12.9 本章小结"></outline>
					</outline>
					<outline text="第十三章 asyncio并发编程">
						<outline text="13.1 事件循环"></outline>
						<outline text="13.2 协程嵌套"></outline>
						<outline text="13.3 call_soon、call_later、call_at、call_soon_threadsafe"></outline>
						<outline text="13.4 ThreadPoolExecutor+asyncio"></outline>
						<outline text="13.5 asyncio模拟http请求"></outline>
						<outline text="13.6 future和task"></outline>
						<outline text="13.7 asyncio同步和通信"></outline>
						<outline text="13.8 aiohttp实现高并发爬虫"></outline>
						<outline text="13.9 本章小结"></outline>
					</outline>
				</outline>
				<outline text="备注">
					<outline text="每行少于80个字符">
						<outline text="换行方法">
							<outline text="\"></outline>
							<outline text="()"></outline>
						</outline>
					</outline>
					<outline text="pass 占位"></outline>
					<outline text="代码块"></outline>
					<outline text="print( ,end=&apos;&apos;)"></outline>
					<outline text="round(a,2)"></outline>
					<outline text="序列解包"></outline>
					<outline text="变成开闭原则">
						<outline text="对扩展开放"></outline>
						<outline text="对修改本身封闭"></outline>
					</outline>
					<outline text="元组不可变 生成器"></outline>
					<outline text="None">
						<outline text="空"></outline>
						<outline text="不存在"></outline>
						<outline text="类型，值 独特"></outline>
					</outline>
					<outline text="vscode">
						<outline text="files.exclude"></outline>
					</outline>
				</outline>
				<outline text="爬虫">
					<outline text="设计思路">
						<outline text="确定所需数据"></outline>
						<outline text="找到对应网页"></outline>
						<outline text="分析网站结构 html信息 找到标签位置"></outline>
						<outline text="模拟并向服务器发送http请求 获取网页"></outline>
						<outline text="用正则表达式提取数据"></outline>
					</outline>
					<outline text="类设计">
						<outline text="私有方法"></outline>
						<outline text="类变量"></outline>
						<outline text="类入口（主方法）"></outline>
					</outline>
					<outline text="方法">
						<outline text="urllib.request.urlopen()"></outline>
						<outline text="str(reponse,encoding=&apos;utf-8&apos;)"></outline>
						<outline text="找标签定位">
							<outline text="唯一标识"></outline>
							<outline text="最接近目标数据"></outline>
							<outline text="标签合并分组"></outline>
							<outline text="&lt;标签&gt;([\s\S]*?)&lt;/标签&gt;"></outline>
							<outline text="精炼数据 refine"></outline>
						</outline>
						<outline text="获取数据">
							<outline text="re.findall"></outline>
						</outline>
						<outline text="排序">
							<outline text="sorted(序列, key=函数,revese=True)"></outline>
							<outline text="函数">
								<outline text="findall(&quot;\d*&quot;,string)"></outline>
								<outline text="字符处理"></outline>
							</outline>
							<outline text="return 某key的value值"></outline>
						</outline>
						<outline text="展现"></outline>
					</outline>
					<outline text="爬虫框架">
						<outline text="scrapy"></outline>
						<outline text="beautifulsoap"></outline>
					</outline>
					<outline text="原则">
						<outline text="函数的行数应该在10-20行左右"></outline>
					</outline>
					<outline text="挑战">
						<outline text="反爬虫"></outline>
						<outline text="ip代理"></outline>
					</outline>
				</outline>
			</outline>
			<outline text="数据库">
				<outline text="有状态的地方就有数据库">
					<outline text="网站的背后"></outline>
					<outline text="应用的内部"></outline>
					<outline text="单机软件"></outline>
					<outline text="区块链"></outline>
					<outline text="Web浏览器中">
						<outline text="各类状态管理框架"></outline>
						<outline text="本地存储"></outline>
					</outline>
				</outline>
				<outline text="分类
关系型数据库只是数据系统的冰山一角（或者说冰山之巅）">
					<outline text="数据库：存储数据，以便自己或其他应用程序之后能再次找到（PostgreSQL，MySQL，Oracle）">
						<outline text="关系型数据库"></outline>
					</outline>
					<outline text="缓存：记住开销昂贵操作的结果，加快读取速度（Redis，Memcached）"></outline>
					<outline text="搜索索引：允许用户按关键字搜索数据，或以各种方式对数据进行过滤（ElasticSearch）"></outline>
					<outline text="流处理：向其他进程发送消息，进行异步处理（Kafka，Flink，Storm）"></outline>
					<outline text="批处理：定期处理累积的大批量数据（Hadoop）"></outline>
				</outline>
				<outline text="架构师">
					<outline text="职能">
						<outline text="了解这些组件的性能特点与应用场景"></outline>
						<outline text="灵活地权衡取舍"></outline>
						<outline text="集成拼接这些数据系统"></outline>
					</outline>
					<outline text="挑战">
						<outline text="软硬件故障把数据搞成一团浆糊（可靠性）"></outline>
						<outline text="状态太多而内存太小放不下（可伸缩性）"></outline>
						<outline text="并发访问控制导致代码复杂度发生爆炸（可维护性）"></outline>
					</outline>
					<outline text="分拆:架构演化的重要方法论">
						<outline text="状态与计算相分离： 数据库将状态管理的职能从应用程序中分拆出来"></outline>
						<outline text="问题比方法更重要: 每个系统都服务于一个目的，解决一类问题"></outline>
					</outline>
					<outline text="理解原理">
						<outline text="设计系统时以最少的复杂度代价写出更可靠高效的代码"></outline>
						<outline text="排查疑难杂症时带来精准的直觉与深刻的洞察"></outline>
					</outline>
				</outline>
				<outline text="原理">
					<outline text="存储引擎原理（基础）"></outline>
					<outline text="数据模型设计原理（应用）
就是生产中的数据结构设计
为了把事情做漂亮（可维护）">
						<outline text="范式理论: 为了解决数据冗余">
							<outline text="冗余度">
								<outline text="冗余少则复杂度小/可维护性强"></outline>
								<outline text="冗余高则性能好"></outline>
							</outline>
							<outline text="冗余字段能加快特定类型的读取（通过消除连接），但在写入时就需要做更多的工作：维护多对象副本间的一致性，避免多对象事务并发执行时发生踩踏"></outline>
						</outline>
					</outline>
					<outline text="索引与查询优化器的原理（性能）
关系代数
为了把事情做得快（性能，可扩展）">
						<outline text="R树索引 GIST索引"></outline>
					</outline>
					<outline text="事务与并发控制的原理（正确性）
为了把事情做正确">
						<outline text="事务是数据处理领域最伟大的抽象之一
提供了很多有用的保证（ACID）"></outline>
						<outline text="原子性: 提交前能随时中止事务并丢弃所有写入"></outline>
						<outline text="持久性: 承诺一旦事务成功提交，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失"></outline>
						<outline text="隔离性:保证同时执行的事务无法相互影响（在可序列化隔离等级下）"></outline>
					</outline>
					<outline text="故障恢复与复制系统的原理（可靠性）">
						<outline text="高可用"></outline>
						<outline text="核心技术其实就是复制（Replication）（或再加上自动故障切换（Failover））"></outline>
					</outline>
				</outline>
			</outline>
			<outline text="语言todo">
				<outline text="C"></outline>
				<outline text="C++"></outline>
				<outline text="javascript"></outline>
				<outline text="安卓开发">
					<outline text="java"></outline>
				</outline>
			</outline>
			<outline text="结构性知识todo">
				<outline text="数据结构/算法(基础)"></outline>
				<outline text="体系结构"></outline>
				<outline text="数字电路"></outline>
				<outline text="离散数学"></outline>
				<outline text="计算机网络"></outline>
				<outline text="操作系统"></outline>
			</outline>
			<outline text="程序设计">
				<outline text="编译原理"></outline>
				<outline text="编程思想">
					<outline text="面向过程"></outline>
					<outline text="面向对象">
						<outline text="现实时间的各种关系映射到计算机里"></outline>
						<outline text="代码组织的方式"></outline>
					</outline>
					<outline text="面向函数"></outline>
				</outline>
				<outline text="编程语言体系"></outline>
			</outline>
		</outline>
		<outline text="XMind: ZEN - Trial Version"></outline>
	</body>
</opml>
